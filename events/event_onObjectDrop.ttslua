local eventDrop = {}
local ShowCast = true
local dropPos = {draw = Vector(56.50, 0, -21.98), stack = Vector(70.95, 0, -6.00)}

    function eventDrop.MonesteryDrop(obj)
        local vec1 = Vector(obj.getPosition().x, 0, obj.getPosition().z)
        local ammount = 0

        for k, vec2 in pairs(dropPos) do
            if vec1:equals(vec2, 5) then
                if k == 'draw' then
                    obj.setName('Discovered Monasteries')
                    Wait.condition(function()
                        Wait.frames(function()processMonistaryStack()end, 1)
                    end, function() return objectHasDropped(obj) end)
                elseif k == 'stack' then
                    obj.setName('Monasteries')
                end
            end
        end

    end

    function objectHasDropped(obj)
        if obj.isDestroyed() then return true end
        return obj.resting
    end

    function processMonistaryStack()
        local stackPos = {stack=Vector(56.51, 2.18, -21.98), drawPile=Vector(70.95, 1.95, -6.00)}
        local cardSlots = {Vector(49.51, 2.02, -21.98), Vector(42.51, 2.02, -21.98), Vector(35.51, 2.02, -21.99), Vector(28.51, 2.02, -21.99), Vector(21.51, 2.02, -21.99)}
        local deck = {draw = {deck=false, pos=Vector(63.51, 2.23, -29.97)}, discard={deck=false, pos=Vector(70.50, 2.01, -30.00)}}
     -- Cast for table State
     -- find card offer, count tokens and find draw and discard decks
        local stackCount = castStack(stackPos.stack)
        for k,v in ipairs(cardSlots) do
            cardSlots[k] = castOffer(v)
        end
        for k,v in pairs(deck) do
            deck[k].deck = castDecks(v.pos)
        end
        --print(logString(cardSlots, '\n---- cardSlots'))
        --print(logString(deck, '\n---- deck'))
        local waitCount = 0
        if not deck.draw.deck then
            resetDeck(deck)
            waitCount = 2.5
            deck.draw.deck = deck.discard.deck
            deck.discard.deck = false
        end
        --print(deck.draw.deck)
        --print(deck.discard.deck)
        Wait.time(function()
            Wait.condition(function() dealOffer(deck.draw.deck, cardSlots, stackCount) end, function() return not deck.draw.deck.isSmoothMoving() end)
        end, waitCount)
        --print(logString(deck, '\n---- deck'))
    end

    function dealOffer(drawDeck, cardSlots, stackCount) --dealOffer(deck.draw.deck, cardSlots)
        local drawTo = 1
        for i = #cardSlots, 1, -1 do
            --print(cardSlots[i].draw)
            if cardSlots[i].draw == false then
            drawTo = i+1
            break  -- Exit the loop once the last true is found
            end
        end
        local card = drawDeck.takeObject({position = cardSlots[drawTo].pos+Vector(0,2,0), rotation=Vector(0,180,0)})
        Wait.condition(function() card.setPositionSmooth(cardSlots[drawTo].pos) end, function() return not card.isSmoothMoving() end)
    end


    function resetDeck(deck)
        --print('MissingDeck')
        local draw, discard = deck.draw.deck, deck.discard.deck
        local drawPos, discardPos = deck.draw.pos, deck.discard.pos
        local waitCount = 0.8
        discard.setPositionSmooth(drawPos+Vector(0,2,0))
        discard.setRotationSmooth(Vector(0,180,180))
        Wait.condition(function()
            discard.setPositionSmooth(drawPos)
                Wait.condition(function()
                    discard.shuffle()
                end, function() return not discard.isSmoothMoving() end)
            end,
            function() return not discard.isSmoothMoving() end)
    end

    function castDecks(castOrigin)
        local zone = Physics.cast({ origin=castOrigin + Vector(0, 1, 0),
                                    direction={0,1,0},
                                    type=3,
                                    max_distance=0,
                                    size=Vector(2,2,2),
                                    debug=ShowCast})
        return processCast_Decks(zone)
    end

    function processCast_Decks(zone)
        for k,v in pairs(zone) do
            local obj = v.hit_object
            if obj.type == 'Deck' then
                return obj
            end
        end
        return false
    end

    function castOffer(castOrigin)
        local zone = Physics.cast({ origin=castOrigin + Vector(0, 1, 0),
                                    direction={0,1,0},
                                    type=3,
                                    max_distance=0,
                                    size=Vector(2,2,2),
                                    debug=ShowCast})
        return processCast_Offer(zone, castOrigin)
    end

    function processCast_Offer(zone, castOrigin)
        local z = {draw = true, card = false, pos = castOrigin}
        for k,v in pairs(zone) do
            local obj = v.hit_object
            if obj.type == 'Card' then
                z.draw = false
                z.card = obj
            end
        end
        return z
    end

    function castStack(castOrigin)
        local zone = Physics.cast({ origin=Vector(56.54, 2.82, -23.17),
                                    direction={0,1,0},
                                    type=3,
                                    max_distance=0,
                                    size=Vector(2,2,2),
                                    debug=ShowCast})
        return processCast_stack(zone)
    end

    function processCast_stack(zone)
        local count = 0
        for k,v in pairs(zone) do
            local obj = v.hit_object
            if obj.hasTag('MonasteryDiscoverToken') then
                count = obj.getQuantity()
                if count == -1 then count = 1 end
                break
            end
        end
        return count
    end

    --[[
    if v.hit_object.type == "Card" or v.hit_object.type == "Deck" then
        object = v.hit_object
    end
    ]]
return eventDrop
